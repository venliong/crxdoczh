<h1><!--@Accessing Hardware Devices-->访问硬件设备</h1>

<p>
<!--@This doc shows you how packaged apps can connect to USB devices
and read from and write to a user's serial ports.
See also the reference docs for the-->
该文档向您演示了打包应用如何连接到 USB
设备并读取和写入用户的串行端口。请参见
<a href="usb.html">USB API</a>
<!--@and the
-->与<a href="serial.html"><!--@Serial-->串行端口 API</a><!--@.
The -->的文档。<a href="bluetooth.html"><!--@Bluetooth-->蓝牙 API</a><!--@ is also available;
we've include a link to a Bluetooth sample below.-->
也可以使用了，我们在下面包含了一个蓝牙示例的链接。
</p>

<p class="note">
<b>API <!--@Samples: -->示例：</b><!--@
Want to play with the code?
Check out the-->想试试这些代码吗？请参见
<a href="https://github.com/GoogleChrome/chrome-app-samples/tree/master/serial">serial</a><!--@,
-->、<a href="https://github.com/GoogleChrome/chrome-app-samples/tree/master/servo">servo</a><!--@,
-->、<a href="https://github.com/GoogleChrome/chrome-app-samples/tree/master/usb">usb</a><!--@,
and -->
及
<a href="https://github.com/GoogleChrome/chrome-app-samples/tree/master/zephyr_hxm">zephyr_hxm <!--@Bluetooth-->蓝牙</a><!--@ samples.-->示例。
</p>

<h2 id="usb"><!--@Accessing USB devices-->访问 USB 设备</h2>

<p>
<!--@You can use the USB API to send messages to connected devices using only JavaScript code. Some devices are not accessible through this API - see the <a href="#caveats">Caveats section</a> below for more details.-->
只要使用 JavaScript 代码，您就可以使用 USB API
向已连接的设备发送消息。某些设备不能通过该 API
访问，请参见下面的<a href="#caveats">注意事项</a>部分了解详情。
</p>

<h3 id="manifest"><!--@Manifest requirement-->清单文件的要求</h3>

<p>
<!--@The USB API requires a special permission "usb" in the manifest file:-->
USB API 要求清单文件中包含特殊的 "usb" 权限：
</p>

<pre>
"permissions": [
  "usb"
]
</pre>

<h3 id="finding_device"><!--@Finding a device-->找到设备</h3>

<p>
<!--@Every device in a USB bus is identified
by its vendor and product IDs.
To find a device,
use the <code>findDevices()</code> method
which has two parameters:-->
USB 总线的每一个设备都由制造商与产品 ID
标志。要找到某个设备，使用具有两个参数的
<code>findDevices()</code> 方法：
</p>

<pre>
chrome.usb.findDevices(FindDeviceOptions, callback)
</pre>

<br>

<table class="simple">
  <tr>
    <th scope="col"> <!--@Parameter (type)-->参数（类型） </th>
    <th scope="col"> <!--@Description-->描述 </th>
  </tr>
  <tr>
    <td>FindDeviceOptions (object)</td>
    <td><!--@An object specifying both a <code>vendorId</code> (long) and
      <code>productId</code> (long) used to find the correct type of device on
      the bus. Before calling this, your extension manifest must declare the
      <code>optional_permissons</code> with a <code>usbDevices</code>
      section containing the same <code>vendorId</code> and
      <code>deviceId</code> combination and must have received user consent
      via <code>chrome.permissions.request(...)</code>.-->
      指定 <code>vendorId</code> (long) 和 <code>productId</code> (long)
      的对象，用来寻找总线上正确类型的设备。调用前，您的扩展程序的清单文件必须在
      <code>optional_permissons</code> （可选权限）中的
      <code>usbDevices</code> 部分声明同样的 <code>vendorId</code> 和
      <code>deviceId</code>，并且必须通过
      <code>chrome.permissions.request(...)</code>
      得到用户的同意。
    </td>
  </tr>
  <tr>
    <td>callback (function)</td>
    <td><!--@Called when the device scan is finished.
      The callback will be executed with one parameter, an array of device objects
      with three properties: <code>handle</code>,
      <code>vendorId</code>,
      <code>productId</code>. If the optional permissions for this USB device
      were not declared in the extension manifest or the user did not consent
      to the permissions requested, the parameter will be <code>null</code>.
      If no devices could be found, the array will be empty.-->
      当设备扫描完成后调用。执行回调函数时会传递一个参数，为设备对象的数组，包含三个属性：<code>handle</code>、<code>vendorId</code>、<code>productId</code>。如果该 USB 设备的可选权限没有在扩展程序的清单文件中声明，或者用户不同意请求的权限，该参数将为
      <code>null</code>。如果没有找到设备，该数组为空。
    </td>
  </tr>
</table>

<p>
<!--@Example:-->
例如：
</p>

<pre>
var onDeviceFound = function(devices) {
  _this.devices=devices;
  if (devices) {
    if (devices.length &gt; 0) {
      console.log("发现设备："+devices.length);
    } else {
      console.log("找不到设备");
    }
    console.log("没有正确请求权限");
  }
};

chrome.usb.findDevices({"vendorId": vendorId, "productId": productId}, onDeviceFound);
</pre>

<h3 id="usb_transfers"><!--@USB transfers and receiving data from a device-->USB 传输以及从设备接收数据</h3>

<p>
<!--@USB protocol defines four types of transfers:
<a href="#control_transfers">control</a>, <a href="#bulk_transfers">bulk</a>, <a href="#isochronous_transfers">isochronous</a> and <a href="#interrupt_transfers">interrupt</a>.
Theoretically they can occur in both directions:<br>
device-to-host (inbound) and host-to-device (outbound).-->
USB 协议定义了四种类型的传输：<a href="#control_transfers"
>控制</a>、<a href="#bulk_transfers"
>大块</a>、<a href="#isochronous_transfers"
>同步</a>与<a href="#interrupt_transfers"
>中断</a>。理论上说，它们都能双向进行：设备到主机（传入）与主机到设备（传出）。
</p>

<p>
<!--@However, due to the nature of the USB protocol, both inbound and outbound messages must be initiated by the host (your computer). For inbound (device-to-host) messages, the host, your JavaScript code, sends a message flagged as "inbound" to the device. The exact contents of the message depends on the device, but usually will have some identification of what you are requesting from it. The device then responds with the requested data. The device's response is handled by Chrome and delivered asynchronously to the callback you specified in the transfer method.
An outbound (host-to-device) message is similar, but the response doesn't contain data returned from the device.-->
然而，由于 USB
协议的本质，传入与传出消息都必须由主机（您的计算机）发起。对于传入（设备到主机）消息，主机，即您的
JavaScript，向设备发送标记为“传入”的消息。消息的具体内容取决于设备，但是通常包含某些信息，标识您请求的内容。然后设备以请求的数据响应。设备的响应由
Chrome 浏览器处理，并异步地传递给您在传输方法中指定的回调函数。传出（主机到设备）消息与之类似，但是响应不包含从设备返回的数据。
</p>

<p><!--@For each message from the device,
the specified callback will receive 
an event object with the following properties:-->
对于来自设备的每一条消息，<code>onEvent</code>
回调函数都会接收一个具有如下属性的事件对象：
</p>

<br>

<table class="simple">
  <tr>
    <th scope="col"> <!--@Property-->属性 </th>
    <th scope="col"> <!--@Description-->描述 </th>
  </tr>
  <tr>
    <td>resultCode (integer)</td>
    <td><!--@0 is success; other values indicate failure. An error string can be read from
      <code>chrome.extension.lastError</code> when a failure is indicated.-->
      0 表示成功，其他值表示失败。表示失败时可以从
      <code>chrome.extension.lastError</code>
      读取错误字符串。
    </td>
  </tr>
  <tr>
    <td>data (arraybuffer)</td>
    <td><!--@Contains the data sent by the device if transfer was inbound.-->
    如果是传入传输则包含设备发送的数据。
    </td>
  </tr>
</table>

<p>
<!--@Example:-->
例如：
</p>

<pre>
var onTransferCallback = function(event) {
   if (event &amp;&amp; event.resultCode === 0 &amp;&amp; event.data) {
     console.log("收到 "+event.data.byteLength+" 字节");
   }
};

chrome.usb.bulkTransfer(device, transferInfo, onTransferCallback);
</pre>

<h3 id="control_transfers"><!--@CONTROL transfers--><b>控制</b>传输</h3>

<p>
Control transfers are generally used to send or receive configuration
or command parameters to a USB device.
The method is simple and receives three parameters:
</p>

<pre>
chrome.usb.controlTransfer(deviceObj, transferInfo, transferCallback)
</pre>

<br>

<table class="simple">
  <tr>
    <th scope="col"> <!--@Parameter (type)-->参数（类型） </th>
    <th scope="col"> <!--@Description-->描述 </th>
  </tr>
  <tr>
    <td>deviceObj</td>
    <td><!--@Object sent in <code>findDevice()</code> callback.-->
    <code>findDevice()</code> 回调函数中发送的对象。
    </td>
  </tr>
  <tr>
    <td>transferInfo</td>
    <td><!--@Parameter object with values from the table below.
      Check your USB device protocol specification for specifics.-->
      参数对象，包含来自下表的值。参考您的 USB 设备协议规范了解具体的值。
    </td>
  </tr>
  <tr>
    <td>transferCallback()</td>
    <td><!--@Invoked when the transfer has completed.-->
      传输完成时调用。
    </td>
  </tr>
</table>

<p>
<!--@Values for <code>transferInfo</code> object:-->
<code>transferInfo</code> 对象的值：
</p>

<table class="simple">
  <tr>
    <th scope="col"> <!--@Value-->值 </th>
    <th scope="col"> <!--@Description-->描述 </th>
  </tr>
  <tr>
    <td>requestType&nbsp;(string)</td>
    <td>"vendor"<!--@, -->、"standard"<!--@, -->、"class" <!--@or-->或 "reserved"<!--@.-->。</td>
  </tr>
  <tr>
    <td>recipient&nbsp;(string)</td>
    <td>"device"<!--@, -->、"interface"<!--@, -->、"endpoint" <!--@or-->或 "other"<!--@.-->。</td>
  </tr>
  <tr>
    <td>direction&nbsp;(string)</td>
    <td>"in" <!--@or-->或 "out"<!--@.-->。<!--@
      -->"in"<!--@ direction is used to notify the device
      that it should send information to the host.
      All communication in a USB bus is host-initiated,
      so use an 'in' transfer to allow a device
      to send information back.-->（输入）方向用于通知设备应该向主机发送信息，USB
      总线中的所有通信都是主机启动的，所以使用 "in" 传输允许设备发回信息。</td>
  </tr>
  <tr>
    <td>request&nbsp;(integer)</td>
    <td><!--@Defined by your device's protocol.-->由您的设备协议定义。</td>
  </tr>
  <tr>
    <td>value&nbsp;(integer)</td>
    <td><!--@Defined by your device's protocol.-->由您的设备协议定义。</td>
  </tr>
  <tr>
    <td>index&nbsp;(integer)</td>
    <td><!--@Defined by your device's protocol.-->由您的设备协议定义。</td>
  </tr>
  <tr>
    <td>length&nbsp;(integer)</td>
    <td><!--@Only used when direction is "in".
      Notifies the device that this is the amount
      of data the host is expecting in response.-->
      只有当 direction 为 "in"
      时才使用，通知设备主机期望的响应包含的数据量。
    </td>
  </tr>
  <tr>
    <td>data&nbsp;(arraybuffer)</td>
    <td><!--@Defined by your device's protocol,
      required when direction is "out".-->
      由您的设备协议定义，当 direction 为 "out" 时必选。
    </td>
  </tr>
</table>

<p>
<!--@Example:-->
例如：
</p>

<pre>
var transferInfo = {
   "requestType": "vendor",
   "recipient": "device",
   "direction": "out",
   "request":  0x31,
   "value": 120,
   "index": 0,
   "data": new Uint8Array([4, 8, 15, 16, 23, 42]).buffer
 };
chrome.usb.controlTransfer(deviceObj, transferInfo, optionalCallback);
</pre>

<h3 id="isochronous_transfers"><!--@ISOCHRONOUS transfers--><b>同步</b>传输</h3>

<p>
<!--@Isochronous transfers is the most complex type of USB transfers. They are commonly used for streams of data, like video and sound. To initiate an isochronous transfer (either inbound or outbound), you must use:-->
同步传输是最复杂的 USB
传输类型，通常用于数据流，例如视频与声音。要开始同步传输（无论是传入还是传出），您必须使用：
</p>

<pre>
chrome.usb.isochronousTransfer(deviceObj, isochronousTransferInfo, transferCallback)
</pre>

<br>

<table class="simple">
  <tr>
    <th scope="col"> <!--@Parameter-->参数 </th>
    <th scope="col"> <!--@Description-->描述 </th>
  </tr>
  <tr>
    <td>deviceObj</td>
    <td><!--@Object sent on <code>findDevice()</code> callback.-->
      传递给 <code>findDevice()</code> 回调函数的对象。
    </td>
  </tr>
  <tr>
    <td>isochronousTransferInfo</td>
    <td><!--@Parameter object with the values in the table below.-->
      参数对象，包含来自下表的值。
    </td>
  </tr>
  <tr>
    <td>transferCallback()</td>
    <td><!--@Invoked when the transfer has completed.-->
      传输完成时调用。
    </td>
  </tr>
</table>

<p>
<!--@Values for <code>isochronousTransferInfo</code> object:-->
用于 <code>isochronousTransferInfo</code> 对象的值：
</p>

<table class="simple">
  <tr>
    <th scope="col"> <!--@Value-->值 </th>
    <th scope="col"> <!--@Description-->描述 </th>
  </tr>
  <tr>
    <td>transferInfo&nbsp;(object)</td>
    <td><!--@An object with the following attributes:-->包含下列属性的参数对象：<br>
      <b>direction (string): </b>"in" <!--@or-->或 "out"<!--@.-->。<br>
      <b>endpoint (integer): </b><!--@defined by your device. Usually can be found by looking at an USB instrospection tool, like <code>lsusb -v</code>-->由您的设备协议定义，通常可以通过 USB
      检测工具找到，例如 <code>lsusb -v</code>。<br>
      <b>length (integer): </b><!--@only used when direction is "in".
      Notifies the device that this is the amount
      of data the host is expecting in response. Should be AT LEAST <code>packets * packetLength</code>-->只有当
      direction 为 "in" 时才使用，通知设备主机期望的响应包含的数据量，至少为
      <code>packets * packetLength</code>。<br>
      <b>data (arraybuffer): </b><!--@defined by your device's protocol;
      only used when direction is "out".-->
      由您的设备协议定义，只有当 direction 为 "out" 时才使用。
    </td>
  </tr>
  <tr>
    <td>packets&nbsp;(integer)</td>
    <td><!--@Total number of packets expected in this transfer.-->本次传输期望的数据包总数。</td>
  </tr>
  <tr>
    <td>packetLength&nbsp;(integer)</td>
    <td><!--@Expected length of each packet in this transfer.-->本次传输期望的每一个数据包的长度。</td>
  </tr>
</table>

<p>
<!--@Example:-->
例如：
</p>

<pre>
var transferInfo = {
   "direction": "in",
   "endpoint": 1,
   "length": 2560
 };
var isoTransferInfo = {
  "transferInfo": transferInfo,
  "packets": 20,
  "packetLength": 128
};
chrome.usb.isochronousTransfer(deviceObj, isoTransferInfo, optionalCallback);
</pre>

<p>
  <b><!--@Notes:-->注意：</b><!--@ One isochronous transfer will contain <code>isoTransferInfo.packets</code> packets of <code>isoTransferInfo.packetLength</code> bytes. If it is an inbound transfer (your code requested data from the device), the <code>data</code> field in the onUsbEvent will be an ArrayBuffer of size <code>transferInfo.length</code>. It is your duty to walk through this ArrayBuffer and extract the different packets, each starting at a multiple of <code>isoTransferInfo.packetLength</code> bytes. If you are expecting a stream of data from the device, remember that you will have to send one "inbound" transfer for each transfer you expect back. USB devices don't send transfers to the bus unless the host explicitly requests them through "inbound" transfers.-->一次同步传输将包含
  <code>isoTransferInfo.packets</code>个数据包，每个数据包
  <code>isoTransferInfo.packetLength</code>
  字节。如果是传入传输（您的代码向设备请求数据），onUsbEvent 中的
  <code>data</code> 字段会是一个大小为 <code>transferInfo.length</code>
  的数组缓冲区（ArrayBuffer）。您应当分析该数组缓冲区，并提取不同的数据包，每个数据包以
  <code>isoTransferInfo.packetLength</code>
  字节的整数倍开始。如果您期望从设备接收到数据流，牢记对于您期望返回的每一次传输您都必须发送一次“传入”传输。除非主机显式通过“传入”传输请求，USB
  设备不会向总线发送传输。
</p>

<h3 id="bulk_transfers"><!--@BULK transfers--><b>大块</b>传输</h3>

<p>
<!--@Bulk transfer is an USB transfer type commonly used
to transfer a large amount of data in a reliable way.
The method has three parameters:-->
大块传输是通常用于以可靠的方式传输大量数据的 USB
传输类型。该方法包含三个参数：
</p>

<pre>
chrome.usb.bulkTransfer(deviceObj, transferInfo, transferCallback)
</pre>

<br>

<table class="simple">
  <tr>
    <th scope="col"> <!--@Parameter-->参数 </th>
    <th scope="col"> <!--@Description-->描述 </th>
  </tr>
  <tr>
    <td>deviceObj</td>
    <td><!--@Object sent on <code>findDevice()</code> callback.-->
      传递给 <code>findDevice()</code> 回调函数的对象。
    </td>
  </tr>
  <tr>
    <td>transferInfo</td>
    <td><!--@Parameter object with the values in the table below.-->
      参数对象，包含来自下表的值。
    </td>
  </tr>
  <tr>
    <td>transferCallback</td>
    <td><!--@Invoked when the transfer has completed.-->
      传输完成时调用。
    </td>
  </tr>
</table>

<p>
<!--@Values for <code>transferInfo</code> object:-->
<code>transferInfo</code> 对象的值：
</p>

<table class="simple">
  <tr>
    <th scope="col"> <!--@Value-->值 </th>
    <th scope="col"> <!--@Description-->描述 </th>
  </tr>
  <tr>
    <td>direction (string)</td>
    <td>"in" <!--@or-->或 "out"<!--@.-->。</td>
  </tr>
  <tr>
    <td>endpoint (integer)</td>
    <td><!--@Defined by your device's protocol.-->由您的设备协议定义。</td>
  </tr>
  <tr>
    <td>length (integer)</td>
    <td><!--@Only used when direction is "in".
      Notifies the device that this is the amount
      of data the host is expecting in response.-->
      只有当 direction 为 "in" 时才使用，通知设备主机期望的响应包含的数据量。
    </td>
  </tr>
  <tr>
    <td>data (ArrayBuffer)</td>
    <td><!--@Defined by your device's protocol;
      only used when direction is "out".-->
      由您的设备协议定义，只有当 direction 为 "out" 时才使用。
    </td>
  </tr>
</table>

<p>
<!--@Example:-->
例如：
</p>

<pre>
var transferInfo = {
   "direction": "out",
   "endpoint": 1,
   "data": new Uint8Array([4, 8, 15, 16, 23, 42]).buffer
 };
</pre>

<h3 id="interrupt_transfers"><!--@INTERRUPT transfers--><b>中断</b>传输</h3>

<p>
<!--@Interrupt transfers are used to send important notifications.
Since all USB communication is initiated by the host,
host code usually polls the device periodically,
sending interrupt IN transfers that will make the device send data back
if there is anything in the interrupt queue.
The method has three parameters:-->
中断传输用来发送重要的通知。由于所有 USB
通信都由主机启动，主机代码通常会周期性地查询设备，发送中断输入传输，如果中断队列不为空的话使设备发回数据。该方法包含三个参数：
</p>

<pre>
chrome.usb.interruptTransfer(deviceObj, transferInfo, transferCallback)
</pre>

<br>

<table class="simple">
  <tr>
    <th scope="col"> <!--@Parameter-->参数 </th>
    <th scope="col"> <!--@Description-->描述 </th>
  </tr>
  <tr>
    <td>deviceObj</td>
    <td><!--@Object sent on <code>findDevice()</code> callback.-->
      传递给 <code>findDevice()</code> 回调函数的对象。
    </td>
  </tr>
  <tr>
    <td>transferInfo</td>
    <td><!--@Parameter object with the values in the table below.-->
      参数对象，包含来自下表的值。
    </td>
  </tr>
  <tr>
    <td>transferCallback</td>
    <td><!--@Invoked when the transfer has completed.
      Notice that this callback doesn't contain the device's response.
      It's just to notify your code that the asynchronous transfer request
      has been processed and you can go ahead.
      The device's response, if any, will always be sent through
      the <code>onEvent()</code> callback set on <code>findDevice()</code>.-->
      传输完成时调用。注意该回调函数并不包含来自设备的任何回应，它只是通知您的代码异步传输请求已处理，您可以继续往前走，设备的响应（如果有的话）一定会通过
      <code>findDevice()</code> 设置的 <code>onEvent()</code> 回调函数发送。
    </td>
  </tr>
</table>

<p>
<!--@Values for <code>transferInfo</code> object:-->
<code>transferInfo</code> 对象的值：
</p>

<table class="simple">
  <tr>
    <th scope="col"> <!--@Value-->值 </th>
    <th scope="col"> <!--@Description-->描述 </th>
  </tr>
  <tr>
    <td>direction (string)</td>
    <td>"in" <!--@or-->或 "out"<!--@.-->。</td>
  </tr>
  <tr>
    <td>endpoint (integer)</td>
    <td><!--@Defined by your device's protocol.-->由您的设备协议定义。</td>
  </tr>
  <tr>
    <td>length (integer)</td>
    <td><!--@Only used when direction is "in".
      Notifies the device that this is the amount
      of data the host is expecting in response.-->
      只有当 direction 为 "in"
      时才使用，通知设备主机期望的响应包含的数据量。
    </td>
  </tr>
  <tr>
    <td>data (ArrayBuffer)</td>
    <td><!--@Defined by your device's protocol;
      only used when direction is "out".-->
      由您的设备协议定义，只有当 direction 为 "out" 时才使用。
    </td>
  </tr>

<p>
<!--@Example:-->例如：
</p>

<pre>
var transferInfo = {
   "direction": "in", 
   "endpoint": 1,
   "length": 2
 };
chrome.usb.interruptTransfer(deviceObj, transferInfo, optionalCallback);
</pre>

<h3 id="caveats"><!--@Caveats-->注意事项</h3>

<p>
<!--@On most Linux systems, USB devices are mapped with read-only permissions by default. To access it through this API, your user will need to have write access too. A simple solution is to set a udev rule. Create a file <code>/etc/udev/rules.d/50-yourdevicename.rules</code>
with the following content:-->
在大部分 Linux 系统上，USB 设备默认情况下以只读权限映射。要通过该 API
访问它，您的用户也需要写入的访问权限。一种简单的解决办法是设置 udev
规则。创建一个包含如下内容的文件：<code>/etc/udev/rules.d/50-<em>yourdevicename</em>.rules</code>：
</p>

<pre>
SUBSYSTEM=="usb", ATTR{idVendor}=="[<em>yourdevicevendor</em>]", MODE="0664", GROUP="plugdev"
</pre>

<p>
  <!--@Then, just restart the udev daemon: <code>service udev restart</code>. You can check if the permissions are correctly set by:-->
  然后，重新启动 udev 服务：<code>service udev restart</code>。您可以通过如下方法检查权限是否正确设置：
  <ul>
    <li><!--@Find the bus and device numbers in <code>lsusb</code>-->
      在 <code>lsusb</code> 中找到总线与设备号。
    </li>
    <li><code>ls -al /dev/bus/usb/[bus]/[device]</code><!--@. This file should be owned by group "plugdev" and have group write permissions.-->。该文件应该由“plugdev”组所有，并包含写入权限。
    </li>
  </ul>
</p>

<p>
<!--@  Not all devices can be accessed through this API. In general, devices are not accessible either because the Operating System's kernel or a native driver holds them off from user space code. Some examples are devices with HID profiles on OSX systems and USB pen drives.-->
并不是所有设备都能通过该 API
访问。大体上，不能访问设备的原因包括操作系统内核或原生设备驱动程序阻止用户区代码访问，例如
OSX 系统上包含 HID 配置文件的设备以及 USB 闪存盘。
</p>

<h2 id="serial"><!--@Accessing serial devices-->访问串行端口设备</h2>

<p>
<!--@You can use the serial API to read
and write from a serial device.-->
您可以使用串行端口 API 读取和写入串行端口设备。
</p>

<h3 id="requirement"><!--@Manifest requirement-->清单文件的要求</h3>

<p>
<!--@You must add the "serial" permission to the manifest file:-->
您必须在清单文件中加入 "serial" 权限：
</p>
<pre>
"permissions": [
  "serial"
]
</pre>

<h3 id="listing"><!--@Listing available serial ports-->列举可用的串行端口</h3>

<p>
<!--@To get a list of available serial ports,
use the <code>getPorts()</code> method. <b>Note:</b> not all serial ports are available. The API uses a heuristic based on the name of the port to only expose serial devices that are expected to be safe.-->
要获取可用串行端口的列表，请使用 <code>getPorts()</code>
方法。<b>注意：</b>并不是所有的串行端口都可用。该 API
采用启发式的方式，基于端口名称，只暴露被视为安全的串行端口设备。
</p>

<pre>
var onGetPorts = function(ports) {
  for (var i=0; i&lt;ports.length; i++) {
    console.log(ports[i]);
  }
}
chrome.serial.getPorts(onGetPorts);
</pre>

<h3 id="opening"><!--@Opening a serial device-->打开串行端口设备</h3>

<p>
<!--@If you know the serial port name, you can open it for read and write using the <code>open</code> method:-->
如果您知道串行端口的名称，您可以使用 <code>open</code> 方法打开它用于读写：
</p>

<pre>
chrome.serial.open(portName, options, openCallback)
</pre>

<table border="0">
  <tr>
    <th scope="col"> <!--@Parameter-->参数 </th>
    <th scope="col"> <!--@Description-->描述 </th>
  </tr>
  <tr>
    <td>portName&nbsp;(string)</td>
    <td><!--@If your device's port name is unknown, you can use the <code>getPorts</code> method.-->
      如果您的设备的端口名未知，您可以使用 <code>getPorts</code> 方法。
    </td>
  </tr>
  <tr>
    <td>options&nbsp;(object)</td>
    <td><!--@Parameter object with one single value: <code>bitrate</code>, an integer specifying the desired bitrate used to communicate with the serial port.-->
    包含单个值的参数对象：<code>bitrate</code>，为一个整数，指定用于与串行端口通信时希望使用的比特率。
  </td>
  </tr>
  <tr>
    <td>openCallback</td>
    <td><!--@Invoked when the port has been successfully opened. The callback will be called with one parameter, <code>openInfo</code>, that has one attribute, <code>connectionId</code>. Save this id, because you will need it to actually communicate with the port.-->
    端口成功打开后调用。该回调函数调用时将传递一个参数
    <code>openInfo</code>，包含一个属性
    <code>connectionId</code>，请保存该标识符，因为您需要它才能与端口进行实际的通信。
    </td>
  </tr>
</table>

<p><!--@A simple example:-->一个简单的例子：</p>

<pre>
var onOpen = function(connectionInfo) {
   // 串行端口已打开，保存其标识符以便以后使用。
  _this.connectionId = connectionInfo.connectionId;
  // 对已打开的端口做任何您需要做的事情。
}
// 打开串行端口 /dev/ttyS01
chrome.serial.open("/dev/ttyS01", {bitrate: 115200}, onOpen);
</pre>

<h3 id="closing"><!--@Closing a serial port-->关闭串行端口</h3>

<p>
<!--@Closing a serial port is simple but very important. See the example below: -->
关闭串行端口很简单但是很重要，请参见下面的例子：
</p>

<pre>
var onClose = function(result) {
 console.log("串行端口已关闭");
}
chrome.serial.close(connectionId, onClose);
</pre>

<h3 id="reading"><!--@Reading from a serial port-->读取串行端口</h3>

<p>
<!--@The serial API reads from the serial port and
delivers the read bytes as an ArrayBuffer.
There is no guarantee that all the requested bytes, even if available in the port, will be read in one chunk.
The following example can accumulate read bytes, at most 128 at a time, until a new line is read,
and then call a listener with the <code>ArrayBuffer</code> bytes converted to a String:-->
串行端口 API 从串行端口读取数据并以 <code>ArrayBuffer</code>
的方式传递已读取的字节。不能保证所有请求的字节（即使在端口中可用）都能在一个片段中读取。如下过程可以积累读取的字节，一次最多
128 字节，直到读到了换行符，然后调用监听器，传递转换为字符串的
<code>ArrayBuffer</code>：
</p>

<pre>
var dataRead='';

var onCharRead=function(readInfo) {
    if (!connectionInfo) {
      return;
    }
    if (readInfo &amp;&amp; readInfo.bytesRead&gt;0 &amp;&amp; readInfo.data) {
      var str=ab2str(readInfo.data);
      if (str[readInfo.bytesRead-1]==='\n') {
        dataRead+=str.substring(0, readInfo.bytesRead-1);
        onLineRead(dataRead);
        dataRead="";
      } else {
        dataRead+=str;
      }
    }
    chrome.serial.read(connectionId, 128, onCharRead);
  }

/* 将 ArrayBuffer 转换为字符串，使用 UTF-8 编码方案，
   这和 Arduino 默认情况下发送字符串的方式一致 */
  var ab2str=function(buf) {
    return String.fromCharCode.apply(null, new Uint8Array(buf));
  };
</pre>

<h3 id="writing"><!--@Writing to a serial port-->写入串行端口</h3>

<p>
<!--@The writing routine is simpler than reading,
since the writing can occur all at once.
The only catch is that if your data protocol is String based,
you have to convert your output string to an <code>ArrayBuffer</code>.
See the code example below:-->
写入例程比读取简单，因为写入操作可以一次完成。唯一的问题是，如果您的数据协议基于字符串，您必须将您的输出字符串转换为
<code>ArrayBuffer</code>。请参考下列代码：
</p>

<pre>
var writeSerial=function(str) {
  chrome.serial.write(connectionId, str2ab(str), onWrite);
}
// 将字符串转换为 ArrayBuffer
var str2ab=function(str) {
  var buf=new ArrayBuffer(str.length);
  var bufView=new Uint8Array(buf);
  for (var i=0; i&lt;str.length; i++) {
    bufView[i]=str.charCodeAt(i);
  }
  return buf;
}
</pre>

<h3 id="flushing"><!--@Flushing a serial port buffer-->清洗串行端口缓存</h3>

<p>
<!--@You can flush your serial port buffer by issuing the flush command:-->
您可以通过发出清洗命令清除串行端口缓存：
</p>

<pre>
  chrome.serial.flush(connectionId, onFlush);
</pre>

